/**
 * Tripletex Authentication
 * Handles token-based authentication for Tripletex API
 * 
 * Tripletex uses a two-token system:
 * 1. Consumer Token - Identifies the app (Knud), set in environment
 * 2. Employee Token - Generated by user in Tripletex, provided at login
 * 
 * These are combined to create a Session Token via the API.
 * Session tokens expire after 24 hours by default.
 */

import { prisma } from "../db.js";
import { encrypt, decrypt } from "../utils/encryption.js";

const TRIPLETEX_API_URL = process.env.TRIPLETEX_API_URL || "https://tripletex.no/v2";

interface SessionTokenResponse {
  value: {
    id: number;
    version: number;
    employeeToken: {
      id: number;
      description?: string;
    };
    consumerToken: {
      id: number;
      description?: string;
    };
    token: string;
    expirationDate: string;
  };
}

interface TripletexCompany {
  id: number;
  name: string;
  organizationNumber?: string;
}

interface TripletexEmployee {
  id: number;
  firstName: string;
  lastName: string;
  displayName?: string;
  email?: string;
}

interface WhoAmIResponse {
  value: {
    employeeId: number;
    companyId: number;
    employee: { id: number };
    company: { id: number };
  };
}

interface EmployeeResponse {
  value: TripletexEmployee;
}

interface CompanyResponse {
  value: TripletexCompany;
}

export interface LoggedInUserInfo {
  employeeId: number;
  employee: TripletexEmployee;
  companyId: number;
  company: TripletexCompany;
}

/**
 * Check if Tripletex is configured
 */
export function isTripletexConfigured(): boolean {
  return !!(
    process.env.TRIPLETEX_CONSUMER_TOKEN &&
    process.env.TRIPLETEX_API_URL
  );
}

/**
 * Check if Tripletex feature is enabled
 */
export function isTripletexEnabled(): boolean {
  return process.env.TRIPLETEX_ENABLED === "true";
}

/**
 * Create a session token using consumer token and employee token
 * Session tokens are valid for 24 hours by default
 * 
 * @param employeeToken - The employee token from the user
 * @param expirationDate - Optional expiration date (default: tomorrow)
 */
export async function createSessionToken(
  employeeToken: string,
  expirationDate?: string
): Promise<SessionTokenResponse["value"]> {
  const consumerToken = process.env.TRIPLETEX_CONSUMER_TOKEN;
  
  if (!consumerToken) {
    throw new Error("TRIPLETEX_CONSUMER_TOKEN is not configured");
  }

  // Default expiration: 24 hours from now
  const expDate = expirationDate || new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split("T")[0];

  // Tripletex requires Basic auth with format: 0:consumerToken for session creation
  // Then the employee token is passed as a query parameter
  const credentials = Buffer.from(`0:${consumerToken}`).toString("base64");

  const url = `${TRIPLETEX_API_URL}/token/session/:create?consumerToken=${encodeURIComponent(consumerToken)}&employeeToken=${encodeURIComponent(employeeToken)}&expirationDate=${expDate}`;

  const response = await fetch(url, {
    method: "PUT",
    headers: {
      "Content-Type": "application/json",
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error("Tripletex session creation failed:", response.status, errorText);
    
    if (response.status === 401) {
      throw new Error("Ugyldig employee token. Sjekk at token er korrekt og ikke utløpt.");
    }
    if (response.status === 404) {
      throw new Error("Tripletex API ikke tilgjengelig. Prøv igjen senere.");
    }
    
    throw new Error(`Kunne ikke opprette Tripletex-sesjon: ${response.status}`);
  }

  const data: SessionTokenResponse = await response.json();
  return data.value;
}

/**
 * Get the logged-in user's info from Tripletex
 * This makes multiple API calls to get full employee and company details
 */
export async function getLoggedInUser(sessionToken: string): Promise<LoggedInUserInfo> {
  const authHeader = `Basic ${Buffer.from(`0:${sessionToken}`).toString("base64")}`;
  
  // First, get the basic whoAmI info to get IDs
  const whoAmIResponse = await fetch(`${TRIPLETEX_API_URL}/token/session/%3EwhoAmI`, {
    headers: { Authorization: authHeader },
  });

  if (!whoAmIResponse.ok) {
    const errorText = await whoAmIResponse.text();
    console.error("Tripletex whoAmI failed:", whoAmIResponse.status, errorText);
    throw new Error("Kunne ikke hente brukerinfo fra Tripletex");
  }

  const whoAmI: WhoAmIResponse = await whoAmIResponse.json();
  
  // Fetch full employee details
  const employeeResponse = await fetch(
    `${TRIPLETEX_API_URL}/employee/${whoAmI.value.employeeId}`,
    { headers: { Authorization: authHeader } }
  );
  
  if (!employeeResponse.ok) {
    throw new Error("Kunne ikke hente ansattinfo fra Tripletex");
  }
  
  const employeeData: EmployeeResponse = await employeeResponse.json();
  
  // Fetch full company details
  const companyResponse = await fetch(
    `${TRIPLETEX_API_URL}/company/${whoAmI.value.companyId}`,
    { headers: { Authorization: authHeader } }
  );
  
  if (!companyResponse.ok) {
    throw new Error("Kunne ikke hente selskapsinfo fra Tripletex");
  }
  
  const companyData: CompanyResponse = await companyResponse.json();

  return {
    employeeId: whoAmI.value.employeeId,
    employee: employeeData.value,
    companyId: whoAmI.value.companyId,
    company: companyData.value,
  };
}

/**
 * Get a valid session token for a user, refreshing if necessary
 */
export async function getValidSessionToken(userId: string): Promise<string | null> {
  const connection = await prisma.accountingConnection.findUnique({
    where: {
      userId_provider: {
        userId,
        provider: "tripletex",
      },
    },
  });

  if (!connection) {
    return null;
  }

  // Check if session token is expired (with 1 hour buffer)
  const now = new Date();
  const expiresAt = new Date(connection.expiresAt);
  const bufferMs = 60 * 60 * 1000; // 1 hour

  if (now.getTime() + bufferMs >= expiresAt.getTime()) {
    // Session token is expired or about to expire, create a new one
    if (!connection.employeeToken) {
      console.error("No employee token stored for Tripletex - user needs to reconnect");
      return null;
    }

    try {
      const decryptedEmployeeToken = decrypt(connection.employeeToken);
      const newSession = await createSessionToken(decryptedEmployeeToken);

      // Update session token in database
      await prisma.accountingConnection.update({
        where: {
          userId_provider: {
            userId,
            provider: "tripletex",
          },
        },
        data: {
          accessToken: newSession.token,
          expiresAt: new Date(newSession.expirationDate),
        },
      });

      return newSession.token;
    } catch (error) {
      console.error("Failed to refresh Tripletex session:", error);
      return null;
    }
  }

  return connection.accessToken;
}

/**
 * Save Tripletex connection for a user
 */
export async function saveTripletexConnection(
  userId: string,
  employeeToken: string,
  sessionToken: string,
  expiresAt: Date,
  companyId: string,
  companyName: string,
  organizationNumber?: string
): Promise<void> {
  await prisma.accountingConnection.upsert({
    where: {
      userId_provider: {
        userId,
        provider: "tripletex",
      },
    },
    create: {
      userId,
      provider: "tripletex",
      accessToken: sessionToken,
      employeeToken: encrypt(employeeToken),
      expiresAt,
      companyId,
      companyName,
      organizationNumber,
    },
    update: {
      accessToken: sessionToken,
      employeeToken: encrypt(employeeToken),
      expiresAt,
      companyId,
      companyName,
      organizationNumber,
    },
  });

  // Set Tripletex as active provider
  await prisma.user.update({
    where: { id: userId },
    data: { activeProvider: "tripletex" },
  });
}

/**
 * Delete Tripletex connection for a user
 * Note: Tripletex session tokens cannot be revoked, they just expire
 */
export async function deleteTripletexConnection(userId: string): Promise<void> {
  await prisma.accountingConnection.deleteMany({
    where: {
      userId,
      provider: "tripletex",
    },
  });
}

/**
 * Get Tripletex connection for a user
 */
export async function getTripletexConnection(userId: string) {
  return prisma.accountingConnection.findUnique({
    where: {
      userId_provider: {
        userId,
        provider: "tripletex",
      },
    },
  });
}
